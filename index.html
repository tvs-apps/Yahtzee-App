<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Yahtzee Scorekeeper</title>

<!-- PWA Support -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#007acc">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Yahtzee Scorekeeper">
<link rel="apple-touch-icon" href="icons/icon-192x192.png">

<!-- D3.js for data visualization -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

<style>
 :root {
   --primary-color: #007acc;
   --secondary-color: #005ea3;
   --background-color: #f5f5f5;
   --card-background: linear-gradient(135deg, #007acc 0%, #005ea3 100%);
   --text-light: white;
   --text-dark: #333;
   --border-color: rgba(255,255,255,0.3);
   --color-on-track: #fff;
   --color-above: #4CAF50; /* Subtle green */
   --color-below: #F44336; /* Subtle red */
   --shadow-color: rgba(0,0,0,0.1);
   --section-bg-color: white;
   --subtle-border-color: #ddd;
   --button-secondary-bg: #e0e0e0;
 }

 body.dark-mode {
    --primary-color: #1e88e5;
    --secondary-color: #42a5f5;
    --background-color: #121212;
    --card-background: linear-gradient(135deg, #1e1e1e 0%, #2c2c2c 100%);
    --text-light: #e0e0e0;
    --text-dark: #e0e0e0;
    --border-color: rgba(255,255,255,0.1);
    --shadow-color: rgba(0,0,0,0.5);
    --section-bg-color: #1e1e1e;
    --subtle-border-color: #333;
    --button-secondary-bg: #333;
 }

 body {
   font-family: 'Arial', sans-serif;
   background: var(--background-color);
   margin: 0;
   padding: 0;
   color: var(--text-dark);
   -webkit-font-smoothing: antialiased;
   -moz-osx-font-smoothing: grayscale;
   touch-action: pan-y; /* Allow vertical scroll, prevent browser swipe for navigation */
   transition: background-color 0.3s, color 0.3s;
 }
 h1 {
   text-align: center;
   margin: 20px 0;
   color: var(--primary-color);
 }
 #playerSetup, .score-card, #settingsPage {
   max-width: 500px;
   margin: auto;
   padding: 20px;
   border-radius: 12px;
   box-shadow: 0 4px 12px var(--shadow-color);
   background: var(--section-bg-color);
   box-sizing: border-box;
 }
 #playerSetup, #settingsPage {
   display: flex;
   flex-direction: column;
   gap: 12px;
 }
 input, select, button {
   font-size: 16px;
   padding: 10px;
   border-radius: 8px;
   border: 1px solid var(--subtle-border-color);
   transition: all 0.3s ease;
 }
 button {
   background: var(--primary-color);
   color: var(--text-light);
   cursor: pointer;
   border: none;
   box-shadow: 0 2px 6px var(--shadow-color);
 }
 body.dark-mode button {
     color: #fff;
 }
 button:hover {
   background: var(--secondary-color);
   box-shadow: 0 4px 8px rgba(0,0,0,0.2);
 }
 button[disabled] {
   opacity: 0.5;
   cursor: not-allowed;
   box-shadow: none;
 }
 .score-card {
   background: var(--card-background);
   color: var(--text-light);
   margin: 20px auto;
 }
 .score-card h2 {
   text-align: center;
   margin-top: 0;
   margin-bottom: 20px;
 }
 .category-row {
   display: flex;
   justify-content: space-between;
   align-items: center;
   padding: 10px 0;
   border-bottom: 1px solid var(--border-color);
 }
 .category-row.locked {
   background: rgba(0,0,0,0.15);
   color: #ccc;
 }
 .category-label { flex: 1; }
 .score-input, select {
   width: 80px;
   text-align: center;
   background: var(--section-bg-color);
   color: var(--text-dark);
 }
 .quick-buttons {
   display: flex;
   gap: 4px;
   margin-left: 6px;
 }
 .quick-buttons button {
   background: rgba(255,255,255,0.2);
   padding: 4px 8px;
 }
 .quick-buttons button:hover {
   background: rgba(255,255,255,0.4);
 }
 /* Conditional Coloring for Upper Section Scores */
 .score-above { background-color: rgba(76, 175, 80, 0.7); } /* Green */
 .score-below { background-color: rgba(244, 67, 54, 0.7); } /* Red */
 .score-on-track { background-color: rgba(255, 255, 255, 0.2); } /* Default/White */


 #footer {
   position: sticky;
   bottom: 0;
   background: var(--section-bg-color);
   padding: 15px;
   text-align: center;
   box-shadow: 0 -2px 10px var(--shadow-color);
   display: none;
   z-index: 50;
 }
 #footer-content {
   display: flex;
   flex-direction: column;
   align-items: center;
   gap: 12px;
 }
 #runningTotals {
   display: block;
   padding: 12px;
   background: #eee;
   border-radius: 8px;
   font-weight: bold;
   color: #333; /* Keep dark text for readability */
   width: 100%;
   overflow-x: auto;
   white-space: nowrap;
 }
  .footer-player-link {
    cursor: pointer;
    padding: 2px 5px;
    border-radius: 4px;
    transition: background-color 0.2s;
    display: inline-block;
 }
 .footer-player-link:hover {
    background-color: rgba(0,0,0,0.1);
 }
 body.dark-mode .footer-player-link:hover {
    background-color: rgba(255,255,255,0.1);
 }
 body.dark-mode #runningTotals {
     background: #2c2c2c;
     color: var(--text-dark);
 }
 .totals { font-weight: bold; margin-top: 15px; }
 /* Bonus Tracker Styling */
 .bonus-tracker {
   text-align: center;
   padding: 8px;
   margin: 10px 0;
   border-radius: 6px;
   background: rgba(0,0,0,0.2);
   font-size: 1.1em;
   font-weight: bold;
 }
 .bonus-tracker span.positive { color: var(--color-above); }
 .bonus-tracker span.negative { color: var(--color-below); }


 #statsDashboard {
   display: none;
   max-width: 500px;
   margin: 20px auto;
 }
 .stat-card {
   background: var(--card-background);
   color: var(--text-light);
   border-radius: 12px;
   padding: 15px;
   margin-bottom: 15px;
   box-shadow: 0 4px 12px var(--shadow-color);
 }
 .stat-card h3 {
   margin: 0 0 10px 0;
   text-align: center;
   cursor: pointer;
   transition: all 0.2s ease;
 }
 .stat-card h3:hover {
   transform: scale(1.02);
 }
 .stat-item {
   display: flex;
   justify-content: space-between;
   padding: 4px 0;
   font-size: 15px;
   border-bottom: 1px dashed rgba(255,255,255,0.2);
 }
 .stat-item:last-child { border-bottom: none; }
 .player-list-item {
   display: flex;
   justify-content: space-between;
   align-items: center;
   gap: 8px;
   background: #f0f0f0;
   padding: 8px;
   border-radius: 6px;
 }
 body.dark-mode .player-list-item {
     background: #2c2c2c;
 }
 .player-list-item span {
   display: flex;
   gap: 4px;
 }
 .player-list-item button {
   padding: 4px 8px;
   font-size: 14px;
 }
  /* Recent Players Styling */
 #recentPlayersList {
   display: flex;
   flex-wrap: wrap;
   gap: 8px;
   padding: 10px 0;
   border-top: 1px solid var(--subtle-border-color);
 }
 #recentPlayersList button {
   background: var(--button-secondary-bg);
   color: var(--text-dark);
   padding: 6px 10px;
   font-size: 14px;
 }


 /* Hall of Fame Styling */
 #hallOfFameList {
   list-style: none;
   padding: 0;
   margin: 10px 0;
 }
 .hof-entry {
   background: rgba(255, 255, 0, 0.15); /* Subtle gold tint */
   color: var(--text-dark);
   padding: 10px;
   margin-bottom: 8px;
   border-radius: 8px;
   box-shadow: 0 1px 3px rgba(0,0,0,0.1);
   cursor: pointer;
   transition: background 0.2s;
 }
 .hof-entry:hover {
   background: rgba(255, 255, 0, 0.3);
 }
 .hof-details {
   display: flex;
   justify-content: space-between;
   font-weight: bold;
 }
 .hof-meta {
   font-size: 0.8em;
   color: #666;
   margin-top: 4px;
 }
 body.dark-mode .hof-entry {
     color: #333; /* Keep dark text for readability on gold background */
 }

 /* Settings Page */
 .settings-section {
    padding: 15px 0;
    border-bottom: 1px solid var(--subtle-border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
 }
 .settings-section:last-child {
     border-bottom: none;
 }
 .settings-section h3 {
    margin: 0 0 15px 0;
    width: 100%;
    text-align: center;
    color: var(--primary-color);
 }
 .settings-section button {
    width: 100%;
    margin-top: 10px;
 }
 .settings-section button.danger {
    background: var(--color-below);
 }

/* Toggle Switch CSS */
.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
}
.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
}
.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
}
input:checked + .slider {
  background-color: var(--primary-color);
}
input:focus + .slider {
  box-shadow: 0 0 1px var(--primary-color);
}
input:checked + .slider:before {
  transform: translateX(26px);
}
.slider.round {
  border-radius: 34px;
}
.slider.round:before {
  border-radius: 50%;
}


 /* Modal Styling */
 .modal-overlay {
   position: fixed;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
   background: rgba(0,0,0,0.8);
   display: none;
   justify-content: center;
   align-items: center;
   z-index: 1000;
 }
 .modal {
   background: var(--section-bg-color);
   padding: 25px;
   border-radius: 12px;
   max-width: 90%;
   width: 400px;
   text-align: center;
   box-shadow: 0 8px 24px rgba(0,0,0,0.3);
   animation: fadeIn 0.3s ease;
 }
 .modal h3 { color: var(--primary-color); }
 .modal button {
   width: 100%;
   margin: 8px 0;
 }
 button.dashboard-btn {
   background: #005ea3;
   color: white;
   padding: 10px 15px;
   margin: 10px 0;
 }
 body.dark-mode button.dashboard-btn {
     color: #fff;
 }
 button.dashboard-btn:hover {
   background: #003f6b;
 }
  /* Chart Styling */
 .chart-container-wrapper {
   margin-top: 15px;
   padding: 10px;
   background: rgba(255, 255, 255, 0.9);
   border-radius: 8px;
   box-shadow: 0 2px 8px var(--shadow-color);
   color: #333;
 }
 body.dark-mode .chart-container-wrapper {
     background: rgba(44, 44, 44, 0.9);
     color: var(--text-dark);
 }
 .chart-container-wrapper h4 {
   margin-top: 0;
   padding-bottom: 5px;
   border-bottom: 1px solid var(--subtle-border-color);
   font-size: 1.1em;
 }
 .d3-tooltip {
   position: absolute;
   text-align: center;
   padding: 8px;
   font: 12px sans-serif;
   background: #333;
   color: white;
   border-radius: 4px;
   pointer-events: none;
   z-index: 1001;
 }
  /* D3 specific styling */
 .bar { transition: fill 0.3s ease; }
 .bar:hover { fill: #FFC107; } /* Highlight on hover */
 .arc path { transition: fill 0.3s ease; }
 .arc:hover path { opacity: 0.8; }
 .win-bar { fill: #4CAF50; } /* Green for Wins */
 .loss-bar { fill: #F44336; } /* Red for Losses */

 /* Result Modal Styling */
.result-winner {
  background: linear-gradient(135deg, #fde472, #ffc107);
  color: #333;
  padding: 20px;
  border-radius: 12px;
  text-align: center;
  margin-bottom: 20px;
  position: relative;
  border: 2px solid #fff;
  box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}
.result-winner-trophy {
  font-size: 4em;
  margin-bottom: 10px;
  animation: trophy-pop 0.6s ease-out forwards;
  transform: scale(0);
}
.result-winner-name {
  font-size: 1.8em;
  font-weight: bold;
}
.result-winner-score {
  font-size: 1.2em;
  color: #555;
}
.result-winner-hof {
  font-size: 1.1em;
  font-weight: bold;
  color: #a46d06; /* A darker gold/bronze color */
  margin-top: 10px;
  animation: hof-glow 2s infinite alternate;
}

@keyframes hof-glow {
  from {
    text-shadow: 0 0 5px #fff, 0 0 10px #ffc107;
  }
  to {
    text-shadow: 0 0 10px #fff, 0 0 20px #fde472;
  }
}

@keyframes trophy-pop {
  0% { transform: scale(0) rotate(-30deg); }
  60% { transform: scale(1.2) rotate(10deg); }
  100% { transform: scale(1) rotate(0deg); }
}

.result-player-list {
  list-style: none;
  padding: 0;
  margin: 0;
  text-align: left;
  max-height: 150px;
  overflow-y: auto;
}
.result-player-item {
  display: flex;
  justify-content: space-between;
  padding: 10px;
  background: #f0f0f0;
  border-radius: 8px;
  margin-bottom: 8px;
  color: #333;
}
body.dark-mode .result-player-item {
    background: #2c2c2c;
    color: var(--text-dark);
}
.result-player-item span:first-child {
  font-weight: bold;
}

/* Confetti Animation */
.confetti {
  position: absolute;
  width: 8px;
  height: 16px;
  background: #f00;
  top: -20px;
  opacity: 0.8;
  animation: confetti-fall 3s linear infinite;
}
@keyframes confetti-fall {
  from { transform: translateY(0) rotate(0deg); }
  to { transform: translateY(110vh) rotate(720deg); }
}

/* FIX: Added max-height and overflow to allow scrolling on the historical scorecard modal */
#historicalScoreCard, #rulesModal .modal {
  max-height: 85vh;
  overflow-y: auto;
}

 @keyframes fadeIn {
   from { opacity: 0; transform: translateY(-20px); }
   to { opacity: 1; transform: translateY(0); }
 }
 .player-card-transition {
   animation: cardSlideIn 0.5s ease-out;
 }
 @keyframes cardSlideIn {
   from { transform: translateX(100%); opacity: 0; }
   to { transform: translateX(0); opacity: 1; }
 }


 /* Swiping UI */
 #swipeActions {
   position: fixed;
   bottom: 80px; /* Above the footer */
   left: 50%;
   transform: translateX(-50%);
   display: none;
   z-index: 100;
 }
 #swipeActions button {
   background: rgba(0, 0, 0, 0.7);
   color: white;
   padding: 8px 15px;
   border-radius: 50px;
 }
 .turn-indicator {
  display: inline-block;
  width: 12px;
  height: 12px;
  background-color: #4CAF50;
  border-radius: 50%;
  margin-left: 8px;
  box-shadow: 0 0 6px #4CAF50, 0 0 10px #4CAF50;
  vertical-align: middle;
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0% {
    transform: scale(0.95);
    box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
  }
  70% {
    transform: scale(1);
    box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
  }
  100% {
    transform: scale(0.95);
    box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
  }
}

/* PWA Update Notification */
#update-notification {
    display: none;
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: var(--primary-color);
    color: white;
    padding: 12px 20px;
    border-radius: 50px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    z-index: 2000;
    cursor: pointer;
    font-weight: bold;
}
/* Virtual Dice Roller */
.die {
  width: 50px;
  height: 50px;
  background-color: #fff;
  border-radius: 8px;
  border: 2px solid var(--text-dark);
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 24px;
  font-weight: bold;
  cursor: pointer;
  transition: transform 0.2s, opacity 0.3s;
  user-select: none;
}
.die.kept {
  opacity: 0.6;
  border-color: var(--primary-color);
  transform: scale(0.9);
}
.die-dot {
    width: 10px;
    height: 10px;
    background-color: var(--text-dark);
    border-radius: 50%;
}
body.dark-mode .die {
    background-color: var(--button-secondary-bg);
    border-color: var(--text-dark);
}
body.dark-mode .die-dot {
    background-color: var(--text-dark);
}

/* Dice face layouts */
.die-face {
    width: 100%;
    height: 100%;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    padding: 5px;
    box-sizing: border-box;
}
.die-face .die-dot {
    align-self: center;
    justify-self: center;
}
/* Hide all dots by default */
.die-face .die-dot { visibility: hidden; }

/* Position dots for each face */
.face-1 .dot-5,
.face-2 .dot-1, .face-2 .dot-9,
.face-3 .dot-1, .face-3 .dot-5, .face-3 .dot-9,
.face-4 .dot-1, .face-4 .dot-3, .face-4 .dot-7, .face-4 .dot-9,
.face-5 .dot-1, .face-5 .dot-3, .face-5 .dot-5, .face-5 .dot-7, .face-5 .dot-9,
.face-6 .dot-1, .face-6 .dot-3, .face-6 .dot-4, .face-6 .dot-6, .face-6 .dot-7, .face-6 .dot-9 {
    visibility: visible;
}
@keyframes roll {
    0% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(180deg) scale(1.2); }
    100% { transform: rotate(360deg) scale(1); }
}
.rolling {
    animation: roll 0.5s ease-out;
}
</style>
</head>
<body>


<h1>Yahtzee Scorekeeper</h1>


<div id="playerSetup">
 <div style="display: flex; gap: 8px; align-items: center;">
    <input type="text" id="playerName" placeholder="Enter player name" style="flex: 1;">
    <button aria-label="Settings" style="flex-shrink: 0; width: 44px; height: 44px; background: #888; font-size: 24px; padding: 0; line-height: 44px;" onclick="showSettings()">&#x2699;</button>
 </div>
 <div id="recentPlayers">
  <h4 style="margin: 0 0 5px 0; color: var(--secondary-color);">Recent Players:</h4>
  <div id="recentPlayersList">No recent players.</div>
 </div>
 <div style="display: flex; gap: 8px;">
    <button id="addPlayerBtn" onclick="addPlayer()" style="flex: 1;">Add Player</button>
    <button id="startGameBtn" onclick="startGame()" disabled style="flex: 1;">Start Game</button>
 </div>
 <div id="playerList"></div>
 <div style="display: flex; gap: 8px; margin-top: 10px;">
   <button style="flex: 1;" onclick="showStats()">View Stats</button>
   <button style="flex: 1;" onclick="hideStats()">Hide Stats</button>
 </div>
</div>

<div id="dice-roller-container" style="display:none; max-width: 500px; margin: 10px auto; padding: 15px; background: var(--section-bg-color); border-radius: 12px; box-shadow: 0 4px 12px var(--shadow-color);">
    <div id="dice-area" style="display: flex; justify-content: space-around; margin-bottom: 15px;">
        <!-- Dice will be generated by JS -->
    </div>
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <button id="roll-dice-btn" onclick="rollDice()">Roll Dice</button>
        <div id="rolls-left" style="font-weight: bold; font-size: 1.1em;">Rolls Left: 3</div>
    </div>
</div>

<div id="playerCardContainer" style="display:none"></div>


<div id="swipeActions">
 <button id="returnToTurnBtn" onclick="returnToTurn()">Return to Turn</button>
</div>


<div id="footer">
 <div id="footer-content">
   <div id="runningTotals"></div>
   <button onclick="confirmAbandonGame()">Abandon Game</button>
 </div>
</div>


<div id="statsDashboard"></div>


<div id="settingsPage" style="display:none;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <button onclick="hideSettings()" style="width: auto; padding: 10px 15px;">&#x2190; Back</button>
        <h2 style="color: var(--primary-color); margin: 0; flex-grow: 1; text-align: center;">Settings</h2>
    </div>

    <div class="settings-section">
        <label for="darkModeToggle" style="font-weight: bold;">Dark Mode</label>
        <label class="switch">
            <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()">
            <span class="slider round"></span>
        </label>
    </div>

    <div class="settings-section">
        <div style="flex-grow: 1;">
            <label for="wakeLockToggle" style="font-weight: bold;">Keep Screen On</label>
            <p style="font-size: 0.8em; color: #888; margin: 5px 0 0 0;">Prevents the screen from dimming.</p>
        </div>
        <label class="switch">
            <input type="checkbox" id="wakeLockToggle" onchange="toggleWakeLock()">
            <span class="slider round"></span>
        </label>
    </div>
    
    <div class="settings-section">
        <div style="flex-grow: 1;">
            <label for="virtualDiceToggle" style="font-weight: bold;">Play with Virtual Dice</label>
            <p style="font-size: 0.8em; color: #888; margin: 5px 0 0 0;">Adds a dice roller to the screen.</p>
        </div>
        <label class="switch">
            <input type="checkbox" id="virtualDiceToggle" onchange="toggleVirtualDice()">
            <span class="slider round"></span>
        </label>
    </div>

    <div class="settings-section">
        <button onclick="showRulesModal()">Game Rules & Scoring Guide</button>
    </div>
    
    <div class="settings-section">
        <h3>Data Management</h3>
        <button onclick="exportData()">Export Backup</button>
        <button onclick="document.getElementById('importFile').click()">Import Backup</button>
    </div>
    
    <div class="settings-section">
        <h3>Advanced</h3>
        <button onclick="forceUpdate()">Force App Update</button>
        <p style="font-size: 0.8em; color: #888; width: 100%; text-align: center; margin: 0;">Use this after an update to get the latest version for the homescreen app.</p>
        <button class="danger" onclick="clearGameData()">Delete All Game Data</button>
    </div>
</div>


<!-- Hidden file input for the import feature -->
<input type="file" id="importFile" accept=".json" style="display: none;">


<!-- Global Alert Modal -->
<div id="alertModal" class="modal-overlay">
 <div class="modal">
   <h3 id="alertTitle"></h3>
   <p id="alertMessage"></p>
   <button onclick="closeAlertModal()">OK</button>
 </div>
</div>


<!-- Global Confirmation Modal -->
<div id="confirmModal" class="modal-overlay">
 <div class="modal">
   <h3 id="confirmTitle"></h3>
   <p id="confirmMessage"></p>
   <button id="confirmYesBtn">Yes</button>
   <button id="confirmNoBtn" class="dashboard-btn">No</button>
 </div>
</div>


<!-- Game Result Modal -->
<div id="resultModal" class="modal-overlay">
  <div class="modal" style="width: 400px; max-width: 90%; padding: 15px; position: relative; background: var(--section-bg-color); overflow: hidden;">
    <div id="confetti-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none; z-index: 1;"></div>
    <div id="resultWinnerContainer" style="position: relative; z-index: 2;">
       <!-- JS will populate winner info here -->
    </div>
    <ul id="resultPlayerListContainer" class="result-player-list" style="position: relative; z-index: 2;">
       <!-- JS will populate other players here -->
    </ul>
    <p id="hofMessage" style="margin: 15px 0; position: relative; z-index: 2; font-style: italic; color: #666;"></p>
    <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 10px; position: relative; z-index: 2;">
      <button onclick="viewFinalScorecards()" style="background-color: var(--secondary-color);">View Scorecards</button>
      <div style="display: flex; gap: 10px;">
        <button onclick="startNewGameWithSamePlayers()" style="flex: 1; background-color: var(--color-above);">Play Again</button>
        <button onclick="resetToSetupScreen()" style="flex: 1; background-color: var(--color-below);">Home Screen</button>
      </div>
    </div>
  </div>
 </div>


<!-- Historical Scorecard View Modal -->
<div id="scoreViewModal" class="modal-overlay">
 <div class="modal" id="historicalScoreCard" style="width: 450px; max-width: 90%;">
  
<button onclick="document.getElementById('scoreViewModal').style.display='none'">Close</button>
 </div>
</div>


<!-- Manual Add Score Modal -->
<div id="manualAddModal" class="modal-overlay">
 <div class="modal">
   <h3>Add Historical Score</h3>
   <p>Manually enter a high score from a paper game. A detailed scorecard will not be available.</p>
   <input type="text" id="manualName" placeholder="Player Name" style="width: 100%; margin-bottom: 10px;">
   <input type="date" id="manualDate" style="width: 100%; margin-bottom: 10px;">
   <input type="number" id="manualScore" placeholder="Grand Total Score (e.g., 420)" style="width: 100%; margin-bottom: 20px;">
   <button onclick="addManualScore()">Add Score</button>
   <button onclick="closeManualAddModal()" class="dashboard-btn">Cancel</button>
 </div>
</div>

<!-- Rules Modal -->
<div id="rulesModal" class="modal-overlay">
 <div class="modal" style="text-align: left;">
   <h3 style="text-align: center;">How to Play</h3>
   <div style="max-height: 60vh; overflow-y: auto; padding-right: 15px;">
       <h4>Taking a Turn</h4>
       <p>On each turn, you may roll the dice up to <strong>3 times</strong>.</p>
       <ol style="padding-left: 20px;">
           <li><strong>First Roll:</strong> Roll all 5 dice. You can set aside any "keepers."</li>
           <li><strong>Second & Third Rolls:</strong> Reroll any or all of the dice as you wish.</li>
       </ol>
       <p>After your final roll, you must enter a score or a zero in one of the 13 category boxes.</p>
       <hr>
       <h4>Upper Section Scoring</h4>
       <p><strong>Aces to Sixes:</strong> Score the sum of only the dice with the specified number. For example, if you roll three 4s, you would score 12 in the "Fours" box.</p>
       <p><strong>Upper Bonus:</strong> If your total score for the Upper Section is <strong>63 or more</strong>, you earn a <strong>35-point bonus</strong>.</p>
       <hr>
       <h4>Lower Section Scoring</h4>
       <p><strong>3 of a Kind:</strong> At least three dice of the same number. Score the total of all 5 dice.</p>
       <p><strong>4 of a Kind:</strong> At least four dice of the same number. Score the total of all 5 dice.</p>
       <p><strong>Full House (Three of one, two of another):</strong> Scores <strong>25 points</strong>.</p>
       <p><strong>Small Straight (Sequence of 4):</strong> Scores <strong>30 points</strong>.</p>
       <p><strong>Large Straight (Sequence of 5):</strong> Scores <strong>40 points</strong>.</p>
       <p><strong>Yahtzee (Five of a Kind):</strong> Scores <strong>50 points</strong>.</p>
       <p><strong>Chance:</strong> Score the total of all 5 dice. This is a catch-all for any roll.</p>
       <hr>
       <h4>Yahtzee Bonus & Joker Rules</h4>
       <p>If you roll a Yahtzee but have already scored 50 in the Yahtzee box, you get a <strong>100-point bonus!</strong> You must also use this roll to score in another category, following these "Joker Rules":</p>
       <ul style="padding-left: 20px;">
           <li>You must fill the corresponding Upper Section box (e.g., if you rolled five 4s, you must score in the Fours box).</li>
           <li>If the Upper Section box is already filled, you may score it in any open Lower Section category.</li>
           <li>If all applicable boxes are filled, you must enter a zero in an open Upper Section box.</li>
       </ul>
       <hr>
       <p style="text-align: center; margin-top: 20px;">
           <a href="https://officialgamerules.org/wp-content/uploads/2025/02/Yahtzee-Instructions.pdf" target="_blank" rel="noopener noreferrer">View Full Official Rules (PDF)</a>
       </p>
   </div>
   <button onclick="closeRulesModal()" style="margin-top: 20px;">Close</button>
 </div>
</div>


<!-- PWA Update Notification -->
<div id="update-notification" onclick="installUpdate()">
    Update Ready
</div>



<script src="https://www.gstatic.com/firebasejs/10.1.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.1.0/firebase-firestore-compat.js"></script>


<script>
// --- Firebase Setup ---
// The following config is a placeholder. The actual environment will provide the required global variables.
const firebaseConfig = {
 apiKey: "AIzaSyBkvd10rqLKr40khhZP5X95ZsrWyRjlXRA",
 authDomain: "yahtzee-scoring-tvs.firebaseapp.com",
 projectId: "yahtzee-scoring-tvs",
 storageBucket: "yahtzee-scoring-tvs.firebasestorage.app",
 messagingSenderId: "651930856297",
 appId: "1:651930856297:web:cce851e3b669499fb552bf8"
};
let db;
try {
    firebase.initializeApp(firebaseConfig);
    db = firebase.firestore();
    db.enablePersistence().catch(err => console.log("Firestore persistence error:", err));
} catch (e) {
    console.error("Firebase initialization failed:", e);
}


// --- Constants ---
const categories = [
 "Aces","Twos","Threes","Fours","Fives","Sixes",
 "3 of a Kind","4 of a Kind","Full House","Small Straight","Large Straight",
 "Yahtzee","Yahtzee Bonus","Chance"
];
const upperCats = ["Aces", "Twos", "Threes", "Fours", "Fives", "Sixes"];
const lowerCats = ["3 of a Kind", "4 of a Kind", "Full House", "Small Straight", "Large Straight", "Yahtzee", "Chance"];
const lowerCatsForStats = ["3 of a Kind", "4 of a Kind", "Full House", "Small Straight", "Large Straight", "Yahtzee"]; // Exclude Chance for success rate
const fixedValueCategories = {"Full House":[25],"Small Straight":[30],"Large Straight":[40],"Yahtzee":[50]};
const UPPER_BONUS_THRESHOLD = 63;
const HALL_OF_FAME_SCORE = 400;


// --- Game State ---
let players = [];
let gameHistory = JSON.parse(localStorage.getItem("yahtzeeGameHistory") || "[]");
let currentPlayerIndex = 0;
let displayPlayerIndex = 0; // The index of the player card currently being viewed
let turnMode = false;
let lastAction = null;
let yahtzeeBonusUsedThisTurn = false;
let recentPlayers = JSON.parse(localStorage.getItem("recentPlayers") || "[]");
let firestoreListener = null; // Holds the unsubscribe function for the listener
let activeHallOfFame = []; // Holds the currently displayed HOF data for click handling
let lastFinishedGamePlayers = []; // Store the final state of players for viewing scorecards

// --- Swiping State ---
let touchStartX = 0;
let touchEndX = 0;
const SWIPE_THRESHOLD = 50;

// --- Virtual Dice State ---
let virtualDiceMode = false;
let dice = [
    { value: 1, kept: false }, { value: 2, kept: false }, { value: 3, kept: false },
    { value: 4, kept: false }, { value: 5, kept: false }
];
let rollsLeft = 3;


// --- Helper Functions ---
function getPlayerGrandTotal(player) {
 // Manual entries will have a 'total' property set directly in the 'result' array, but for
 // calculating on the fly from a scorecard, use this:
 if (player.manual && player.total) return player.total;
  const upper = upperCats.reduce((s, c) => s + (player.scores[c] || 0), 0);
 const bonus = upper >= UPPER_BONUS_THRESHOLD ? 35 : 0;
 const lower = lowerCats.reduce((s, c) => s + (player.scores[c] || 0), 0) + (player.scores["Yahtzee Bonus"] || 0);
 return upper + bonus + lower;
}


function getUpperSectionScore(player) {
 return upperCats.reduce((s, c) => s + (player.scores[c] || 0), 0);
}


function updateRunningTotals() {
 const runningDiv = document.getElementById("runningTotals");
 runningDiv.innerHTML = players.map((p, index) => {
   const total = getPlayerGrandTotal(p);
   const isTurn = index === currentPlayerIndex;
   return `<span class="footer-player-link" onclick="jumpToPlayerCard(${index})">${p.name}: ${total}${isTurn ? '<span class="turn-indicator"></span>' : ''}</span>`;
 }).join(' | ');
}


function hidePlayerCardContainer() {
 document.getElementById("playerCardContainer").style.display = "none";
 document.getElementById("footer").style.display = "none";
 document.getElementById("swipeActions").style.display = "none";
 document.getElementById('dice-roller-container').style.display = 'none';
}


// --- Firestore snapshot ---
// This listener keeps gameHistory synced in real-time
function attachFirestoreListener() {
    if (db && !firestoreListener) { // Check if DB is initialized and listener doesn't exist
        console.log("Attaching Firestore listener...");
        firestoreListener = db.collection("yahtzeeGames").onSnapshot(snapshot => {
            // No need to check for local writes; the listener is detached during local writes.
            console.log("Data received from Firestore.");
            gameHistory = snapshot.docs.map(doc => doc.data());
            localStorage.setItem("yahtzeeGameHistory", JSON.stringify(gameHistory));
            // Only update stats if the dashboard is visible to prevent background processing
            if (document.getElementById("statsDashboard").style.display === "block") {
                updateStatsDashboard();
            }
        }, err => {
            console.error("Snapshot listener error:", err);
        });
    }
}
// Initial attachment of the listener on page load
attachFirestoreListener();


// --- Player Management & Recent Players ---
function randomColor() {
 const r = Math.floor(Math.random() * 150) + 50;
 const g = Math.floor(Math.random() * 150) + 50;
 const b = Math.floor(Math.random() * 150) + 50;
 return `rgb(${r},${g},${b})`;
}


function addPlayer() {
 const name = document.getElementById("playerName").value.trim();
 if (!name) return showAlert("Error", "Please enter a player name.");
 if (players.some(p => p.name === name)) return showAlert("Error", `Player "${name}" is already added.`);


 players.push({name, scores: {}, locked: {}, color: randomColor(), yahtzeeBonusCount: 0});
 document.getElementById("playerName").value = "";
 renderPlayerList();
 document.getElementById("startGameBtn").disabled = players.length === 0;
}


function removePlayer(i) {
 players.splice(i, 1);
 renderPlayerList();
 document.getElementById("startGameBtn").disabled = players.length === 0;
}


function renderPlayerList() {
 const list = document.getElementById("playerList");
 list.innerHTML = "";
 players.forEach((p, i) => {
   const div = document.createElement("div");
   div.className = "player-list-item";
   div.innerHTML = `
     <span>${i + 1}. ${p.name}</span>
     <span>
       <button aria-label="Move Up" onclick="movePlayerUp(${i})">↑</button>
       <button aria-label="Move Down" onclick="movePlayerDown(${i})">↓</button>
       <button aria-label="Remove Player" onclick="removePlayer(${i})">✖</button>
     </span>`;
   list.appendChild(div);
 });
 renderRecentPlayers();
}
function movePlayerUp(i) { if (i === 0) return; [players[i - 1], players[i]] = [players[i], players[i - 1]]; renderPlayerList(); }
function movePlayerDown(i) { if (i === players.length - 1) return; [players[i + 1], players[i]] = [players[i + 1], players[i]]; renderPlayerList(); }


function updateRecentPlayers(names) {
   let currentRecent = JSON.parse(localStorage.getItem("recentPlayers") || "[]");
   names.forEach(name => {
       // Remove existing entry to move it to the front
       currentRecent = currentRecent.filter(pName => pName !== name);
       // Add to front
       currentRecent.unshift(name);
   });
   // Keep only the last 5 unique players
   currentRecent = currentRecent.slice(0, 5);
   recentPlayers = currentRecent;
   localStorage.setItem("recentPlayers", JSON.stringify(recentPlayers));
   renderRecentPlayers();
}


function renderRecentPlayers() {
   const list = document.getElementById("recentPlayersList");
   list.innerHTML = "";
   if (recentPlayers.length === 0) {
       list.innerText = "No recent players.";
       return;
   }


   recentPlayers.filter(name => !players.some(p => p.name === name)).forEach(name => {
       const btn = document.createElement("button");
       btn.innerText = name;
       btn.onclick = () => {
           document.getElementById("playerName").value = name;
           addPlayer();
       };
       list.appendChild(btn);
   });
   if (list.innerHTML === "") { list.innerText = "All recent players are currently in the game."; }
}


// --- Game Start ---
function startGame(keepPlayers = false) {
 if (players.length === 0) return showAlert("Error", "Add at least one player");
 if (!keepPlayers) {
   // If starting a brand new game, re-initialize player scores
   players = players.map(p => ({
     name: p.name, scores: {}, locked: {}, color: p.color, yahtzeeBonusCount: 0
   }));
 }
 turnMode = true;
 currentPlayerIndex = 0;
 displayPlayerIndex = 0;
 lastAction = null;
 yahtzeeBonusUsedThisTurn = false;


 hideStats();
 document.getElementById("playerSetup").style.display = "none";
 if (virtualDiceMode) {
    document.getElementById('dice-roller-container').style.display = 'block';
    resetDiceRoller();
 }
 document.getElementById("playerCardContainer").style.display = "block";
 document.getElementById("footer").style.display = "flex";
  // Attach swipe listeners only when starting a game
 const container = document.getElementById("playerCardContainer");
 container.addEventListener('touchstart', handleTouchStart, false);       
 container.addEventListener('touchmove', handleTouchMove, false);
 container.addEventListener('touchend', handleTouchEnd, false);


 renderPlayerCard(false);
}


// --- Scorecard Rendering (Updated for Bonus Tracker & Totals) ---
function renderPlayerCard(animateCard = true, idx = displayPlayerIndex, forModal = false) {
 const container = forModal ? document.getElementById("historicalScoreCard") : document.getElementById("playerCardContainer");
 const playerSource = lastFinishedGamePlayers.length > 0 ? lastFinishedGamePlayers : players; // Use the correct player data source
 const player = playerSource[idx];
 const isCurrentTurn = idx === currentPlayerIndex;
  // Prevent rendering full card for manual history entries inside the view modal
 if (forModal && player.manual) return;
  const card = document.createElement("div");
 card.className = "score-card";
 card.style.background = player.color;
  // 1. Swiping animation: only for multi-player and new turn transitions
 if (animateCard && players.length > 1 && isCurrentTurn && !forModal) {
   card.classList.add("player-card-transition");
 }


 card.innerHTML = `<h2>${player.name}${isCurrentTurn && !forModal && turnMode ? '<span class="turn-indicator"></span>' : ''}</h2>`;
  let upperTotal = 0;
 let bonusTrackerScore = 0;


 categories.forEach(cat => {
   const locked = player.locked[cat] || forModal;
   const row = document.createElement("div");
   row.className = "category-row" + (locked ? " locked" : "");
   let inner = `<div class="category-label">${cat}</div>`;
   const scoreVal = player.scores[cat] || 0;


   // UPPER SECTION Logic (Aces to Sixes)
   if (upperCats.includes(cat)) {
     const num = upperCats.indexOf(cat) + 1; // 1 to 6
     const expectedScore = num * 3;
    
     upperTotal += scoreVal;
    
     // Calculate deviation for Bonus Tracker only if scored/locked
     if (locked) {
         bonusTrackerScore += (scoreVal - expectedScore);
     }


     let scoreClass = 'score-on-track';
     if (scoreVal > expectedScore) { scoreClass = 'score-above'; }
     else if (scoreVal < expectedScore) { scoreClass = 'score-below'; }


     if (locked) {
       inner += `<div class="${scoreClass}" style="padding: 0 10px; border-radius: 4px;">${scoreVal}</div>`;
     } else {
       inner += `<div class="quick-buttons">${[1, 2, 3, 4, 5].map(mult => {
         const val = mult * num;
         const btnClass = val > expectedScore ? 'score-above' : (val < expectedScore ? 'score-below' : 'score-on-track');
         return `<button class="${btnClass}" onclick="updateScore('${cat}',${val})">${val}</button>`;
       }).join('')}</div>`;
       inner += `<button onclick="updateScore('${cat}',0)">Scratch</button>`;
     }
   }
   // LOWER SECTION Logic
   else if (["3 of a Kind", "4 of a Kind", "Chance"].includes(cat)) {
       if (locked) { inner += `<div>${scoreVal}</div>`; }
       else {
           let options = "<option value=''>--</option>";
           const max = cat === "Chance" ? 30 : 30;
           for (let i = 0; i <= max; i++) options += `<option value="${i}">${i}</option>`;
           inner += `<select onchange="updateScore('${cat}',this.value)">${options}</select>`;
           if (cat !== "Chance") { inner += `<button onclick="updateScore('${cat}',0)">Scratch</button>`; }
       }
   } else if (fixedValueCategories[cat]) {
     if (locked) { inner += `<div>${scoreVal}</div>`; }
     else { inner += `<div class="quick-buttons">${fixedValueCategories[cat].map(v => `<button onclick="updateScore('${cat}',${v})">${v}</button>`).join('')}<button onclick="updateScore('${cat}',0)">Scratch</button></div>`; }
   } else if (cat === "Yahtzee Bonus") {
     let xMarks = "X".repeat(player.yahtzeeBonusCount || 0);
     if (player.locked["Yahtzee"] !== true || yahtzeeBonusUsedThisTurn || locked) {
       inner += `<div>${scoreVal} ${xMarks} (locked)</div>`;
     } else {
       inner += `<button onclick="incrementYahtzeeBonus()">+100</button> <span>${xMarks}</span>`;
     }
   }


   row.innerHTML = inner;
   card.appendChild(row);
  
   // Insert the Upper Section Summary after the "Sixes" row
   if (cat === "Sixes") {
       const bonusValue = upperTotal >= UPPER_BONUS_THRESHOLD ? 35 : 0;
       const upperSummaryHTML = `
           <div class="bonus-tracker" style="display: flex; justify-content: space-around; gap: 5px; margin-top: 10px; padding: 10px 0; border-top: 2px solid var(--border-color); border-bottom: 2px solid var(--border-color); background: rgba(0,0,0,0.3);">
               <div style="flex: 1; text-align: center;">
                   Upper Score: <strong>${upperTotal}</strong>
               </div>
               <div style="flex: 1; text-align: center; border-left: 1px solid var(--border-color); border-right: 1px solid var(--border-color);">
                   Tracker:
                   <span class="${bonusTrackerScore >= 0 ? 'positive' : 'negative'}">
                       ${bonusTrackerScore > 0 ? '+' : ''}${bonusTrackerScore}
                   </span>
               </div>
               <div style="flex: 1; text-align: center;">
                   Bonus: <strong>${bonusValue}</strong>
               </div>
           </div>
       `;
       // Use insertAdjacentHTML to place it exactly after the row
       card.lastElementChild.insertAdjacentHTML('afterend', upperSummaryHTML);
   }
 });


 // Calculate and display final totals (Simplified)
 const bonusValue = upperTotal >= UPPER_BONUS_THRESHOLD ? 35 : 0;
 const lowerTotal = lowerCats.reduce((s, c) => s + (player.scores[c] || 0), 0) + (player.scores["Yahtzee Bonus"] || 0);
 const grandTotal = upperTotal + bonusValue + lowerTotal;
  const totalsDiv = document.createElement("div");
 totalsDiv.className = "totals";
 totalsDiv.innerText = `Upper: ${upperTotal + bonusValue} | Lower: ${lowerTotal} | Grand: ${grandTotal}`;
 card.appendChild(totalsDiv);


 if (!forModal) {
   container.innerHTML = "";
   updateRunningTotals();
   card.innerHTML += `<button onclick="undoScore()">Undo Last Input</button>`;
 }
 container.appendChild(card);
}


// --- Swiping Logic (4) ---
function handleTouchStart(evt) {
   const inGame = turnMode;
   const postGame = lastFinishedGamePlayers.length > 0;
   if ((!inGame && !postGame) || players.length < 2) return;
   touchStartX = evt.touches[0].clientX;
}


function handleTouchMove(evt) {
    const inGame = turnMode;
   const postGame = lastFinishedGamePlayers.length > 0;
   if ((!inGame && !postGame) || players.length < 2) return;
   touchEndX = evt.touches[0].clientX;
}


function handleTouchEnd() {
   const inGame = turnMode;
   const postGame = lastFinishedGamePlayers.length > 0;
   if ((!inGame && !postGame) || (inGame && players.length < 2) || (postGame && lastFinishedGamePlayers.length < 2) || touchEndX === 0) return;

   const diff = touchStartX - touchEndX;
   const playerSource = postGame ? lastFinishedGamePlayers : players;


   if (Math.abs(diff) > SWIPE_THRESHOLD) {
       if (diff > 0) {
           // Swiped Left (Next Player)
           displayPlayerIndex = (displayPlayerIndex + 1) % playerSource.length;
       } else {
           // Swiped Right (Previous Player)
           displayPlayerIndex = (displayPlayerIndex - 1 + playerSource.length) % playerSource.length;
       }
      
       renderPlayerCard(false, displayPlayerIndex, postGame);
      
       // Show "Return to Turn" button if not on current player's card
       const swipeActions = document.getElementById("swipeActions");
       if (inGame && displayPlayerIndex !== currentPlayerIndex) {
           swipeActions.style.display = "block";
           document.getElementById("returnToTurnBtn").innerText = `Return to ${players[currentPlayerIndex].name}'s Turn`;
       } else {
           swipeActions.style.display = "none";
       }
   }
   touchStartX = 0;
   touchEndX = 0;
}


function returnToTurn() {
   displayPlayerIndex = currentPlayerIndex;
   renderPlayerCard(false, displayPlayerIndex, false);
   document.getElementById("swipeActions").style.display = "none";
}


// Jumps directly to a player's scorecard from the footer link.
function jumpToPlayerCard(index) {
    const inGame = turnMode;
    const postGame = lastFinishedGamePlayers.length > 0;
    if (!inGame && !postGame) return;
    
    displayPlayerIndex = index;
    renderPlayerCard(false, displayPlayerIndex, false); // FIX: Always render to the main container, not the modal

    const swipeActions = document.getElementById("swipeActions");
    if (inGame && displayPlayerIndex !== currentPlayerIndex) {
        swipeActions.style.display = "block";
        document.getElementById("returnToTurnBtn").innerText = `Return to ${players[currentPlayerIndex].name}'s Turn`;
    } else {
        swipeActions.style.display = "none";
    }
}


// --- Score Handling ---
function updateScore(cat, val) {
 if (val === "" || isNaN(val)) return;
 val = Number(val);


 const player = players[currentPlayerIndex];
 lastAction = {
   playerIndex: currentPlayerIndex,
   cat,
   valOld: player.scores[cat] || 0,
   yahtzeeBonusUsedPrev: yahtzeeBonusUsedThisTurn,
   playerStateSnapshot: JSON.stringify(player) // Snapshot for deeper undo
 };


 player.scores[cat] = val;
 player.locked[cat] = true;


 if (cat === "Yahtzee") {
   // Allow Yahtzee bonus only if Yahtzee was scored (50 points)
   player.locked["Yahtzee Bonus"] = player.scores[cat] !== 50;
 }


 // Only trigger player transition animation and turn change if NOT Yahtzee Bonus
 const animate = cat !== "Yahtzee Bonus" && players.length > 1;


 if (cat !== "Yahtzee Bonus") {
   yahtzeeBonusUsedThisTurn = false;
   nextPlayer();
 }


 renderPlayerCard(animate, currentPlayerIndex, false);
 document.getElementById("swipeActions").style.display = "none"; // Hide swipe actions on score input
 
 // NEW: Check if the game is over after every score update
 checkGameCompletion();
}


function incrementYahtzeeBonus() {
 const player = players[currentPlayerIndex];
 if (yahtzeeBonusUsedThisTurn) return;


 lastAction = {
   playerIndex: currentPlayerIndex,
   cat: "Yahtzee Bonus",
   valOld: player.scores["Yahtzee Bonus"] || 0,
   yahtzeeBonusUsedPrev: yahtzeeBonusUsedThisTurn,
   playerStateSnapshot: JSON.stringify(player)
 };


 player.scores["Yahtzee Bonus"] = (player.scores["Yahtzee Bonus"] || 0) + 100;
 player.yahtzeeBonusCount = (player.yahtzeeBonusCount || 0) + 1;
 yahtzeeBonusUsedThisTurn = true;
  // Re-render current player card without animating
 renderPlayerCard(false, currentPlayerIndex, false);
}


function undoScore() {
 if (!lastAction) return;
  // Restore player state from snapshot
 const { playerIndex, cat, yahtzeeBonusUsedPrev, playerStateSnapshot } = lastAction;
  players[playerIndex] = JSON.parse(playerStateSnapshot);
  currentPlayerIndex = playerIndex;
 displayPlayerIndex = playerIndex;
 yahtzeeBonusUsedThisTurn = yahtzeeBonusUsedPrev;
  lastAction = null;
 renderPlayerCard(false, currentPlayerIndex, false); // Do not animate on undo
 document.getElementById("swipeActions").style.display = "none";
}


function nextPlayer() {
 yahtzeeBonusUsedThisTurn = false;
 currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
 displayPlayerIndex = currentPlayerIndex; // Reset view to current player
 if (virtualDiceMode) { // ADD THIS
    resetDiceRoller();
 }
}


// --- Manual Score Add Functions ---
function showManualAddModal() {
   document.getElementById("manualName").value = "";
   document.getElementById("manualScore").value = "";
   // Set default date to today
   document.getElementById("manualDate").valueAsDate = new Date();
   document.getElementById("manualAddModal").style.display = "flex";
}


function closeManualAddModal() {
   document.getElementById("manualAddModal").style.display = "none";
}


function addManualScore() {
   const name = document.getElementById("manualName").value.trim();
   const dateStr = document.getElementById("manualDate").value;
   const score = parseInt(document.getElementById("manualScore").value, 10);


   if (!name || !dateStr || isNaN(score) || score <= 0) {
       return showAlert("Error", "Please fill out all fields with valid data.");
   }
  
   // 1. Create a minimal game result structure
   const manualResult = [{
       name: name,
       scores: {}, // Empty scores object
       total: score,
       manual: true // Flag this entry as manual
   }];


   // 2. Create the game history entry
   const newGameEntry = {
       date: new Date(dateStr).toISOString(),
       result: manualResult,
       manual: true
   };
  
   // 3. Save to local history
   gameHistory.push(newGameEntry);
   localStorage.setItem("yahtzeeGameHistory", JSON.stringify(gameHistory));


   // 4. Save to Firestore
   if (db) {
        db.collection("yahtzeeGames").add(newGameEntry)
        .then(() => {
            showAlert("Success", `Historical score of ${score} for ${name} added successfully.`);
            closeManualAddModal();
            updateStatsDashboard();
        })
        .catch(error => {
            console.error("Error adding manual document: ", error);
            showAlert("Error", "Failed to save score to the cloud.");
        });
   } else {
        showAlert("Offline", "Score saved locally. It will sync when you are back online.");
        closeManualAddModal();
        updateStatsDashboard();
   }
}


// --- Modals and End Game ---
function showConfirmModal(title, message, onYes, onNo) {
 document.getElementById("confirmTitle").innerText = title;
 document.getElementById("confirmMessage").innerText = message;
 const yesBtn = document.getElementById("confirmYesBtn");
 const noBtn = document.getElementById("confirmNoBtn");


 yesBtn.onclick = () => { closeConfirmModal(); onYes(); };
 noBtn.onclick = () => { closeConfirmModal(); onNo(); };
 document.getElementById("confirmModal").style.display = "flex";
}
function closeConfirmModal() {
 document.getElementById("confirmModal").style.display = "none";
}


function showAlert(title, message) {
 document.getElementById("alertTitle").innerText = title;
 document.getElementById("alertMessage").innerText = message;
 document.getElementById("alertModal").style.display = "flex";
}
function closeAlertModal() {
 document.getElementById("alertModal").style.display = "none";
}


function showResultModal(sortedPlayers, savedToHof) {
 const winner = sortedPlayers[0];
 const winnerTotal = getPlayerGrandTotal(winner);

 const winnerContainer = document.getElementById("resultWinnerContainer");
 const playerListContainer = document.getElementById("resultPlayerListContainer");
 const confettiContainer = document.getElementById("confetti-container");

 // Clear previous results
 winnerContainer.innerHTML = "";
 playerListContainer.innerHTML = "";
 confettiContainer.innerHTML = ""; // Clear old confetti

 // Check if the winner made it to the Hall of Fame
 const winnerInHof = winnerTotal >= HALL_OF_FAME_SCORE;
 const hofMessageHTML = winnerInHof ? `<div class="result-winner-hof">🌟 Welcome to the Hall of Fame! 🌟</div>` : "";

 // Create Winner Card
 winnerContainer.innerHTML = `
   <div class="result-winner">
     <div class="result-winner-trophy">🏆</div>
     <div class="result-winner-name">${winner.name} Wins!</div>
     <div class="result-winner-score">with ${winnerTotal} points</div>
     ${hofMessageHTML}
   </div>
 `;

 // Create list of other players
 sortedPlayers.slice(1).forEach(p => {
   const total = getPlayerGrandTotal(p);
      const isHof = total >= HALL_OF_FAME_SCORE;
   const li = document.createElement("li");
   li.className = "result-player-item";
   li.innerHTML = `<span>${p.name} ${isHof ? '🌟' : ''}</span> <span>${total} points</span>`;
   playerListContainer.appendChild(li);
 });


 // Update HOF message
 document.getElementById("hofMessage").innerText = savedToHof
   ? "Amazing scores! High-scorers have been added to the Hall of Fame."
   : "";

 // Show the modal
 document.getElementById("resultModal").style.display = "flex";

 // Add confetti
 for(let i = 0; i < 50; i++) {
     const confetti = document.createElement('div');
     confetti.className = 'confetti';
     confetti.style.left = Math.random() * 100 + 'vw';
     confetti.style.animationDelay = Math.random() * 3 + 's';
     confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
     confettiContainer.appendChild(confetti);
 }
}


// NEW: Function to check if all players have filled all 13 categories
function checkGameCompletion() {
    if (!turnMode || players.length === 0) return;

    // A game requires 13 locked categories for each player. Yahtzee Bonus is separate.
    const requiredLockedCount = 13;
    const allPlayersFinished = players.every(p => {
        // We count keys, but must exclude the "Yahtzee Bonus" if it's locked, as it's not a mandatory turn.
        const lockedCategories = Object.keys(p.locked).filter(cat => cat !== "Yahtzee Bonus");
        return lockedCategories.length >= requiredLockedCount;
    });

    if (allPlayersFinished) {
        console.log("All players have finished! Ending game automatically.");
        handleAutomaticGameEnd();
    }
}

// NEW: This function handles the automatic end of a completed game.
function handleAutomaticGameEnd() {
    lastFinishedGamePlayers = JSON.parse(JSON.stringify(players)); // Save a snapshot
    const sortedPlayers = [...players].sort((a, b) => getPlayerGrandTotal(b) - getPlayerGrandTotal(a));
    const finalScores = sortedPlayers.map(p => ({
        name: p.name,
        scores: p.scores,
        total: getPlayerGrandTotal(p)
    }));

    // Save to game history and Firestore
    const newGameEntry = { date: new Date().toISOString(), result: finalScores };
    gameHistory.push(newGameEntry);
    localStorage.setItem("yahtzeeGameHistory", JSON.stringify(gameHistory));
    if (db) {
        db.collection("yahtzeeGames").add(newGameEntry);
    }

    // Update recent players list
    const playerNames = players.map(p => p.name);
    updateRecentPlayers(playerNames);

    // Check for Hall of Fame qualification
    const savedToHof = finalScores.some(p => p.total >= HALL_OF_FAME_SCORE);

    // Show result modal
    showResultModal(sortedPlayers, savedToHof);
    hidePlayerCardContainer();
    turnMode = false; // Officially end the game
}

// NEW: This function is called from the "Abandon Game" button in the footer.
function confirmAbandonGame() {
    showConfirmModal(
        "Abandon Game?",
        "Are you sure you want to end the current game? The results will NOT be saved.",
        () => resetToSetupScreen(), // On "Yes", reset without saving
        () => {} // On "No", do nothing
    );
}

// NEW: Function to start a new game with the same set of players.
function startNewGameWithSamePlayers() {
    document.getElementById("resultModal").style.display = "none";
    // Keep player objects but reset scores/locks/bonuses
    const currentPlayers = lastFinishedGamePlayers.length > 0 ? lastFinishedGamePlayers : players;
    players = currentPlayers.map(p => ({
        name: p.name, scores: {}, locked: {}, color: p.color, yahtzeeBonusCount: 0
    }));
    startGame(true); // startGame(true) re-initializes and starts
}

// NEW: Function to view scorecards after a game ends.
function viewFinalScorecards() {
    document.getElementById("resultModal").style.display = "none"; // Hide the results modal
    
    // Set up the game view to show the completed scorecards
    displayPlayerIndex = 0; // Start with the first player
    turnMode = false; // Ensure no turn indicator shows
    
    document.getElementById("playerSetup").style.display = "none";
    document.getElementById("playerCardContainer").style.display = "block";
    
    // Modify footer to show a "Back to Home" button instead of "Abandon Game"
    const footer = document.getElementById("footer");
    footer.style.display = "flex";
    document.getElementById("runningTotals").innerHTML = lastFinishedGamePlayers.map((p, index) => {
        return `<span class="footer-player-link" onclick="jumpToPlayerCard(${index})">${p.name}: ${getPlayerGrandTotal(p)}</span>`;
    }).join(' | ');
    document.getElementById("footer-content").querySelector('button').innerText = "Back to Home Screen";
    document.getElementById("footer-content").querySelector('button').onclick = resetToSetupScreen;
    
    // Enable swiping through scorecards
    const container = document.getElementById("playerCardContainer");
    container.addEventListener('touchstart', handleTouchStart, false);       
    container.addEventListener('touchmove', handleTouchMove, false);
    container.addEventListener('touchend', handleTouchEnd, false);

    renderPlayerCard(false, 0, false); // FIX: Render to the main container, not the modal
}

// NEW: Unified function to reset the game and return to the home screen.
function resetToSetupScreen() {
    document.getElementById("resultModal").style.display = "none";
    players = [];
    lastFinishedGamePlayers = [];
    currentPlayerIndex = 0;
    turnMode = false;
    yahtzeeBonusUsedThisTurn = false;
    
    document.getElementById("playerSetup").style.display = "flex";
    hidePlayerCardContainer();
    
    // Restore footer to its default "Abandon Game" state
    const footerButton = document.getElementById("footer-content").querySelector('button');
    if (footerButton) {
        footerButton.innerText = "Abandon Game";
        footerButton.onclick = confirmAbandonGame;
    }
    
    renderPlayerList();
}


/**
* Forces an application code refresh and data sync.
*/
function forceUpdate() {
   if (updateAvailable && newWorker) {
       showConfirmModal(
           "Install Update?",
           "A new version of the app is ready. Install now?",
           () => {
               newWorker.postMessage({ action: 'skipWaiting' });
           },
           () => {}
       );
   } else {
       showConfirmModal(
           "Force App Refresh",
           "No new update detected. Would you like to force a refresh to check for the latest version from the server?",
           () => {
               window.location.reload(true);
           },
           () => {}
       );
   }
}




// --- Stats and Hall of Fame ---
function calculateStats() {
 const stats = {};
 const hallOfFame = [];
 let totalAllPoints = 0; // For overall average score
 let totalGamesCounted = 0;


 gameHistory.forEach(game => {
   // Re-calculate totals because the historical data might not have the total pre-calculated
   const playersWithScores = game.result.map(p => {
       const isManual = p.manual || !p.scores || Object.keys(p.scores).length === 0;
       const total = isManual
           ? p.total || 0
           : getPlayerGrandTotal({ scores: p.scores || {} });


       return {
           ...p,
           total: total,
           isManual: isManual
       };
   });
   const winnersScore = playersWithScores.length > 0 ? Math.max(...playersWithScores.map(p => p.total)) : 0;
  
   playersWithScores.forEach(p => {
     // Hall of Fame check
     if (p.total >= HALL_OF_FAME_SCORE) {
         hallOfFame.push({
             name: p.name,
             score: p.total,
             date: game.date,
             scorecard: p.isManual ? null : p.scores, // Pass null for manual entries
             isManual: p.isManual
         });
     }


     // Standard Stats calculation
     if (!stats[p.name]) {
         stats[p.name] = {
             games: 0, wins: 0, streak: 0, maxStreak: 0, losingStreak: 0,
             maxLosingStreak: 0, totalPoints: 0, totalScore: 0, avgScore: 0,
             highestScore: 0, highestNoYahtzee: 0, mostYahtzees: 0,
             bonusCount: 0, gamesWithYahtzee: 0, scratchCounts: {},
             headToHead: {},
             categorySuccesses: {}
         };
     }
     const s = stats[p.name];
     s.games++;
     totalGamesCounted++;
    
     // Track all points for overall average
     totalAllPoints += p.total;


     // Skip deep score tracking for manual entries, only track totals/wins/games
     if (!p.isManual) {
         const noY = Object.entries(p.scores).filter(([cat]) => cat !== "Yahtzee" && cat !== "Yahtzee Bonus").reduce((sum, [, v]) => sum + v, 0);
         if (noY > s.highestNoYahtzee) s.highestNoYahtzee = noY;
         const yahtzeesThisGame = Math.floor((p.scores.Yahtzee || 0) / 50) + Math.floor((p.scores["Yahtzee Bonus"] || 0) / 100);
         s.mostYahtzees = Math.max(s.mostYahtzees, yahtzeesThisGame);
         if ((p.scores.Yahtzee || 0) > 0) s.gamesWithYahtzee++;
         s.bonusCount += Math.floor((p.scores["Yahtzee Bonus"] || 0) / 100);
        
         categories.forEach(cat => {
             if (!s.scratchCounts[cat]) { s.scratchCounts[cat] = 0; }
             if (p.scores[cat] === 0) { s.scratchCounts[cat]++; }
         });
        
         // Lower Section Success Tracking (for the new bar chart)
         lowerCatsForStats.forEach(cat => {
             if (!s.categorySuccesses[cat]) { s.categorySuccesses[cat] = 0; }
             // If score is > 0, it was a success (not scratched/zeroed out).
             if ((p.scores[cat] || 0) > 0) {
                 s.categorySuccesses[cat]++;
             }
         });
     }


     if (p.total === winnersScore && playersWithScores.length > 1) {
         s.wins++; s.streak++;
         if (s.streak > s.maxStreak) s.maxStreak = s.streak;
         s.losingStreak = 0;
     } else { s.streak = 0; s.losingStreak++; if (s.losingStreak > s.maxLosingStreak) s.maxLosingStreak = s.losingStreak; }
     s.totalPoints += p.total; s.totalScore += p.total;
     if (p.total > s.highestScore) s.highestScore = p.total;
    
     playersWithScores.forEach(opponent => {
       if (p.name === opponent.name) return;
       if (!s.headToHead[opponent.name]) {
         s.headToHead[opponent.name] = { wins: 0, losses: 0, totalGames: 0 };
       }
       s.headToHead[opponent.name].totalGames++;
       if (p.total > opponent.total) { s.headToHead[opponent.name].wins++; }
       else if (p.total < opponent.total) { s.headToHead[opponent.name].losses++; }
     });
   });
 });


 // Calculate averages and final stats
 for (const player in stats) {
   const s = stats[player];
   s.avgScore = parseFloat((s.totalScore / s.games).toFixed(1));
  
   // Calculate percentage for ALL tracked categories
   for (const cat in s.categorySuccesses) {
     if (s.games > 0) {
       s.categorySuccesses[cat] = parseFloat(((s.categorySuccesses[cat] / s.games) * 100).toFixed(1));
     } else {
       s.categorySuccesses[cat] = 0;
     }
   }
 }
  const overallAvgScore = totalGamesCounted > 0 ? parseFloat((totalAllPoints / totalGamesCounted).toFixed(1)) : 0;


 // Sort Hall of Fame by score (desc) then date (asc)
 hallOfFame.sort((a, b) => b.score - a.score || new Date(a.date) - new Date(b.date));


 return { stats, hallOfFame, overallAvgScore };
}


function renderHallOfFame(hallOfFame) {
    // Calculate the tally of HOF appearances
    const hofTally = hallOfFame.reduce((acc, entry) => {
        acc[entry.name] = (acc[entry.name] || 0) + 1;
        return acc;
    }, {});

    // Sort the tally for display
    const sortedTally = Object.entries(hofTally).sort((a, b) => b[1] - a[1]);

    let hofHtml = `
      <div class="stat-card" style="background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); color: var(--text-dark);">
        <h3 style="color: var(--text-dark);">🏆 Yahtzee Hall of Fame (400+) 🏆</h3>
        <ul id="hallOfFameList">
    `;
  
    if (hallOfFame.length === 0) {
        hofHtml += `<li>No scores of ${HALL_OF_FAME_SCORE}+ yet!</li>`;
    } else {
        hallOfFame.forEach((entry, index) => {
            const dateStr = new Date(entry.date).toLocaleDateString();
            const clickHandler = `viewHistoricalScoreCardByIndex(${index})`;
            hofHtml += `
              <li class="hof-entry" onclick="${clickHandler}">
                <div class="hof-details">
                    <span>${entry.name} ${entry.isManual ? ' (Manual)' : ''}</span>
                    <span>${entry.score}</span>
                </div>
                <div class="hof-meta">
                    Achieved: ${dateStr} (Click to view scorecard)
                </div>
              </li>
            `;
        });
    }

    hofHtml += `</ul>`;

    // Add the tally section if there are any entries
    if (sortedTally.length > 0) {
        hofHtml += `
          <div style="margin-top: 20px; border-top: 1px solid rgba(0,0,0,0.2); padding-top: 15px;">
            <h4 style="margin: 0 0 10px 0; text-align: center;">Total Hall of Fame Appearances</h4>
            <div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">
                ${sortedTally.map(([name, count]) => `
                    <span style="background: rgba(0,0,0,0.1); padding: 5px 10px; border-radius: 15px; font-size: 0.9em;">
                        <strong>${name}:</strong> ${count}
                    </span>
                `).join('')}
            </div>
          </div>
        `;
    }

    hofHtml += `
      <button onclick="showManualAddModal()" class="dashboard-btn" style="width: 100%; background: #9c27b0; margin-top: 20px;">Manually Add Historical Score</button>
      </div>`;
    return hofHtml;
}


// NEW FUNCTION: Handles the click from the HOF list by looking up the data by index.
function viewHistoricalScoreCardByIndex(index) {
    const entry = activeHallOfFame[index];
    if (entry) {
        // Call the original function with the safe, retrieved data.
        viewHistoricalScoreCard(entry.name, entry.score, entry.date, entry.scorecard);
    } else {
        console.error("Could not find Hall of Fame entry for index:", index);
        showAlert("Error", "Could not retrieve the scorecard for that entry.");
    }
}


function viewHistoricalScoreCard(name, total, date, scores) {
   const container = document.getElementById("historicalScoreCard");
   container.innerHTML = `<button onclick="document.getElementById('scoreViewModal').style.display='none'">Close</button>`;


   // Check if scores object is null, undefined, or empty (indicates manual entry)
   const isManual = !scores || Object.keys(scores).length === 0;


   if (isManual) {
       const dateStr = new Date(date).toLocaleDateString();
       container.innerHTML = `
           <h2>${name}</h2>
           <p style="font-size: 1.2em; font-weight: bold; color: green;">Historical Score Added Manually</p>
           <p><strong>Grand Total:</strong> ${total}</p>
           <p><strong>Date Recorded:</strong> ${dateStr}</p>
           <p style="font-style: italic;">No detailed category breakdown is available for manually entered games.</p>
           <button onclick="document.getElementById('scoreViewModal').style.display='none'">Close</button>
       `;
   } else {
       // Create a temporary player object for rendering purposes
       const tempPlayer = {
           name: `${name} (${total} points, ${new Date(date).toLocaleDateString()})`,
           scores: scores,
           // Set locked status based on whether a score exists
           locked: Object.keys(scores).reduce((acc, cat) => {
               acc[cat] = true;
               return acc;
           }, {}),
           color: randomColor(), // Use a random color or base color for viewing
           yahtzeeBonusCount: Math.floor((scores["Yahtzee Bonus"] || 0) / 100),
           manual: false
       };
       // Temporarily use lastFinishedGamePlayers to render the card
       lastFinishedGamePlayers = [tempPlayer];
       renderPlayerCard(false, 0, true); // Render into the modal
       lastFinishedGamePlayers = []; // Clear it after use
       
       container.innerHTML += `<button onclick="document.getElementById('scoreViewModal').style.display='none'">Close</button>`;
   }
  
   document.getElementById('scoreViewModal').style.display='flex';
}


// --- D3 Chart Functions ---


// Global Tooltip
const tooltip = d3.select("body").append("div")
   .attr("class", "d3-tooltip")
   .style("opacity", 0);


function createTooltip(event, text) {
   tooltip.html(text)
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY - 28) + "px");
   tooltip.transition().duration(200).style("opacity", .9);
}


function hideTooltip() {
   tooltip.transition().duration(500).style("opacity", 0);
}


/**
* Renders a bar chart comparing player average score vs. overall average score.
*/
function renderScoreDistributionChart(containerId, playerAvg, overallAvg) {
   const data = [
       { name: "Your Average", value: playerAvg, color: "#4CAF50" },
       { name: "Overall Average", value: overallAvg, color: "#FF9800" }
   ];


   const container = document.getElementById(containerId);
   container.innerHTML = '<h4>Average Score Comparison</h4>';
  
   const margin = {top: 10, right: 10, bottom: 40, left: 40};
   const fixedViewBoxWidth = 300;
   const width = fixedViewBoxWidth - margin.left - margin.right;
   const height = 200 - margin.top - margin.bottom;


   const svg = d3.select(container).append("svg")
       .attr("width", "100%")
       .attr("height", height + margin.top + margin.bottom)
       .attr("viewBox", `0 0 ${fixedViewBoxWidth} ${height + margin.top + margin.bottom}`)
       .append("g")
       .attr("transform", `translate(${margin.left},${margin.top})`);
      
   const yMax = d3.max(data, d => d.value) * 1.1;


   const x = d3.scaleBand()
       .range([0, width])
       .domain(data.map(d => d.name))
       .padding(0.4);


   const y = d3.scaleLinear()
       .range([height, 0])
       .domain([0, yMax < 50 ? 50 : yMax]);


   svg.selectAll(".bar")
       .data(data)
       .enter().append("rect")
       .attr("class", "bar")
       .attr("x", d => x(d.name))
       .attr("y", d => y(d.value))
       .attr("width", x.bandwidth())
       .attr("height", d => height - y(d.value))
       .attr("fill", d => d.color)
       .on("mouseover", (event, d) => createTooltip(event, `<strong>${d.name}:</strong> ${d.value} points`))
       .on("mouseout", hideTooltip);


   // X-Axis
   svg.append("g")
       .attr("transform", `translate(0,${height})`)
       .call(d3.axisBottom(x).tickSize(0).tickPadding(10));


   // Y-Axis
   svg.append("g")
       .call(d3.axisLeft(y).ticks(5));
}


/**
* Renders a vertical bar chart for Lower Section Category Success Rates.
*/
function renderLowerSectionSuccessBarChart(containerId, successData, gamesPlayed) {
   const rawData = lowerCatsForStats.map(cat => ({
       category: cat.replace(/\s/g, '\n'), // Use line breaks for better labels on X-axis
       percent: successData[cat] || 0
   }));


   if (gamesPlayed === 0) {
       const container = document.getElementById(containerId);
       container.innerHTML = '<h4>Lower Section Achievement Rate</h4><p style="text-align:center;">Not enough data yet (0 games).</p>';
       return;
   }


   const container = document.getElementById(containerId);
   container.innerHTML = '<h4>Lower Section Achievement Rate (%)</h4>';


   const margin = {top: 10, right: 10, bottom: 80, left: 40};
   const fixedViewBoxWidth = 500;
   const width = fixedViewBoxWidth - margin.left - margin.right;
   const height = 300 - margin.top - margin.bottom;


   const svg = d3.select(container).append("svg")
       .attr("width", "100%")
       .attr("height", height + margin.top + margin.bottom)
       .attr("viewBox", `0 0 ${fixedViewBoxWidth} ${height + margin.top + margin.bottom}`)
       .append("g")
       .attr("transform", `translate(${margin.left},${margin.top})`);
      
   const x = d3.scaleBand()
       .range([0, width])
       .domain(rawData.map(d => d.category))
       .padding(0.2);


   const y = d3.scaleLinear()
       .range([height, 0])
       .domain([0, 100]);


   svg.selectAll(".bar")
       .data(rawData)
       .enter().append("rect")
       .attr("class", "bar")
       .attr("x", d => x(d.category))
       .attr("y", d => y(d.percent))
       .attr("width", x.bandwidth())
       .attr("height", d => height - y(d.percent))
       .attr("fill", "#03A9F4")
       .on("mouseover", (event, d) => createTooltip(event, `<strong>${d.category.replace('\n', ' ')}:</strong> ${d.percent}%`))
       .on("mouseout", hideTooltip);


   // X-Axis (with rotated labels for clarity)
   svg.append("g")
       .attr("transform", `translate(0,${height})`)
       .call(d3.axisBottom(x))
       .selectAll("text") 
         .style("text-anchor", "end")
         .attr("dx", "-.8em")
         .attr("dy", ".15em")
         .attr("transform", "rotate(-45)");


   // Y-Axis
   svg.append("g")
       .call(d3.axisLeft(y).ticks(5).tickFormat(d => d + "%"));
}


/**
* Renders a horizontal bar chart for Head-to-Head win percentages.
*/
function renderHeadToHeadChart(containerId, headToHeadData) {
   const data = Object.keys(headToHeadData).map(opponent => {
       const record = headToHeadData[opponent];
       const total = record.totalGames;
       return {
           opponent,
           winPercent: total > 0 ? parseFloat(((record.wins / total) * 100).toFixed(1)) : 0,
           lossPercent: total > 0 ? parseFloat(((record.losses / total) * 100).toFixed(1)) : 0,
           totalGames: total,
           record: `${record.wins}-${record.losses}`
       };
   }).filter(d => d.totalGames > 0).sort((a, b) => b.winPercent - a.winPercent); // Sort by highest win rate


   const container = document.getElementById(containerId);
   container.innerHTML = '<h4>Head-to-Head Records (Win %)</h4>';


   if (data.length === 0) {
       container.innerHTML += '<p style="text-align:center;">No head-to-head data yet (play more games with others!).</p>';
       return;
   }
  
   const margin = {top: 10, right: 40, bottom: 20, left: 100};
   const fixedViewBoxWidth = 500;
   const height = data.length * 40 + margin.top + margin.bottom;


   const svg = d3.select(container).append("svg")
       .attr("width", "100%")
       .attr("height", height)
       .attr("viewBox", `0 0 ${fixedViewBoxWidth} ${height}`)
       .append("g")
       .attr("transform", `translate(${margin.left},${margin.top})`);


   const y = d3.scaleBand()
       .range([0, height - margin.top - margin.bottom])
       .domain(data.map(d => d.opponent))
       .padding(0.2);


   const x = d3.scaleLinear()
       .range([0, fixedViewBoxWidth - margin.left - margin.right])
       .domain([0, 100]); // Percentage scale


   // Win Bars
   svg.selectAll(".win-bar")
       .data(data)
       .enter().append("rect")
       .attr("class", "win-bar")
       .attr("y", d => y(d.opponent))
       .attr("x", 0)
       .attr("height", y.bandwidth())
       .attr("width", d => x(d.winPercent))
       .on("mouseover", (event, d) => createTooltip(event, `vs. <strong>${d.opponent}</strong><br>Win %: ${d.winPercent}%<br>Record: ${d.record}`))
       .on("mouseout", hideTooltip);
      
   // Loss Bars (Draw the full 100% bar first, then cover with win bar for context)
   svg.selectAll(".loss-bar-bg")
       .data(data)
       .enter().append("rect")
       .attr("class", "loss-bar")
       .attr("y", d => y(d.opponent))
       .attr("x", 0)
       .attr("height", y.bandwidth())
       .attr("width", x(100))
       .attr("opacity", 0.2); // Make the loss background subtle


   // Y-Axis (Opponent Names)
   svg.append("g")
       .call(d3.axisLeft(y).tickSize(0).tickPadding(5))
       .select(".domain").remove();
      
   // X-Axis (Top Percentage Label)
   svg.append("g")
       .attr("transform", `translate(0, ${-5})`)
       .call(d3.axisTop(x).ticks(5).tickFormat(d => d + "%"));


   // Add labels inside the bar (Win %)
   svg.selectAll(".bar-label")
       .data(data)
       .enter().append("text")
       .attr("class", "bar-label")
       .attr("x", d => x(d.winPercent) - 5) // Position slightly before the end of the win bar
       .attr("y", d => y(d.opponent) + y.bandwidth() / 2)
       .attr("dy", ".35em")
       .style("text-anchor", "end")
       .style("font-size", "10px")
       .style("fill", "white")
       .text(d => d.winPercent > 10 ? `${d.winPercent}%` : '');
      
   // Add total record text on the far right
   svg.selectAll(".record-text")
       .data(data)
       .enter().append("text")
       .attr("class", "record-text")
       .attr("x", x(100) + 5)
       .attr("y", d => y(d.opponent) + y.bandwidth() / 2)
       .attr("dy", ".35em")
       .style("text-anchor", "start")
       .style("font-size", "12px")
       .style("fill", "var(--text-dark)")
       .text(d => `(${d.record})`);
}




function toggleCharts(playerName, stats, button) {
 const parent = button.parentElement;
 let chartWrapper = parent.querySelector(".chart-container-wrapper");
  if (chartWrapper) {
   chartWrapper.style.display = chartWrapper.style.display === "none" ? "block" : "none";
   button.innerText = chartWrapper.style.display === "none" ? "Show Performance Charts" : "Hide Performance Charts";
   return;
 }


 // Create main wrapper
 chartWrapper = document.createElement("div");
 chartWrapper.className = "chart-container-wrapper";
 parent.appendChild(chartWrapper);
 button.innerText = "Hide Performance Charts";
  // Create containers for individual charts
 const chartContainer1 = document.createElement("div");
 chartContainer1.id = `chart-dist-${playerName.replace(/\s/g, '-')}`;
 chartWrapper.appendChild(chartContainer1);
  const chartContainer2 = document.createElement("div");
 chartContainer2.id = `chart-success-${playerName.replace(/\s/g, '-')}`;
 chartWrapper.appendChild(chartContainer2);
  const chartContainer3 = document.createElement("div");
 chartContainer3.id = `chart-h2h-${playerName.replace(/\s/g, '-')}`;
 chartWrapper.appendChild(chartContainer3);




 // Render Chart 1: Score Distribution (Vertical Bar)
 renderScoreDistributionChart(
   chartContainer1.id,
   stats.avgScore,
   stats.overallAvgScore
 );


 // Render Chart 2: Lower Section Success (Vertical Bar)
 renderLowerSectionSuccessBarChart(
   chartContainer2.id,
   stats.categorySuccesses,
   stats.games
 );
  // Render Chart 3: Head-to-Head (Horizontal Bar)
 renderHeadToHeadChart(
   chartContainer3.id,
   stats.headToHead
 );
}




function updateStatsDashboard() {
    const statsDiv = document.getElementById("statsDashboard");
    statsDiv.innerHTML = ""; // Clear existing stats

    const { stats, hallOfFame, overallAvgScore } = calculateStats();
    activeHallOfFame = hallOfFame; // Store the HOF data for the click handler

    // --- NEW LOGIC TO ORDER PLAYERS BY MOST RECENT GAME ---
    const orderedPlayers = [];
    const seenPlayers = new Set();
    // Iterate backwards through history to get the most recent players first
    for (let i = gameHistory.length - 1; i >= 0; i--) {
        const game = gameHistory[i];
        if (game.result) {
            for (const playerResult of game.result) {
                if (playerResult.name && !seenPlayers.has(playerResult.name)) {
                    orderedPlayers.push(playerResult.name);
                    seenPlayers.add(playerResult.name);
                }
            }
        }
    }
    // Ensure any players who might not be in recent games (but exist in stats) are still included at the end.
    Object.keys(stats).forEach(playerName => {
        if (!seenPlayers.has(playerName)) {
            orderedPlayers.push(playerName);
        }
    });
    // --- END NEW LOGIC ---

    // Create and add the Hall of Fame button
    const hofButton = document.createElement("button");
    hofButton.innerText = "🏆 View Hall of Fame 🏆";
    hofButton.className = "dashboard-btn";
    hofButton.style.background = "linear-gradient(135deg, #FFD700 0%, #FFA500 100%)";
    hofButton.style.color = "var(--text-dark)";
    hofButton.style.width = "100%";
    hofButton.style.marginBottom = "15px";
    
    // Create the container for the Hall of Fame list (initially hidden)
    const hofContainer = document.createElement("div");
    hofContainer.id = "hallOfFameContainer";
    hofContainer.style.display = "none";
    
    // Add click event to the button
    hofButton.onclick = () => {
        // Always re-render the list when opening to ensure it's up to date.
        hofContainer.innerHTML = renderHallOfFame(hallOfFame);
        
        // Toggle visibility
        const isHidden = hofContainer.style.display === "none";
        hofContainer.style.display = isHidden ? "block" : "none";
        hofButton.innerText = isHidden ? "Hide Hall of Fame" : "🏆 View Hall of Fame 🏆";
    };

    // Add the button and container to the main stats div
    statsDiv.appendChild(hofButton);
    statsDiv.appendChild(hofContainer);


    // MODIFIED: Loop over the ordered list of players instead of the stats object keys.
    orderedPlayers.forEach(player => {
        const s = stats[player];
        if (!s) return; // Skip if a player from history doesn't have stats for some reason

        const card = document.createElement("div");
        card.className = "stat-card";


        const header = document.createElement("h3");
        header.innerText = player;


        const content = document.createElement("div");
        content.style.display = "none";


        const scratchCats = Object.entries(s.scratchCounts).sort((a, b) => b[1] - a[1]);
  
        content.innerHTML = `
            <div class="stat-item"><span>Games Played:</span><span>${s.games}</span></div>
            <div class="stat-item"><span>Wins:</span><span>${s.wins}</span></div>
            <div class="stat-item"><span>Win %:</span><span>${((s.wins / s.games) * 100).toFixed(1)}%</span></div>
            <div class="stat-item"><span>Longest Winning Streak:</span><span>${s.maxStreak}</span></div>
            <div class="stat-item"><span>Longest Losing Streak:</span><span>${s.maxLosingStreak}</span></div>
            <div class="stat-item"><span>Avg Grand Total:</span><span>${s.avgScore}</span></div>
            <div class="stat-item"><span>Highest Score:</span><span>${s.highestScore}</span></div>
            <div class="stat-item"><span>Highest w/o Yahtzee:</span><span>${s.highestNoYahtzee}</span></div>
            <div class="stat-item"><span>Most Yahtzees in Game:</span><span>${s.mostYahtzees}</span></div>
            <div class="stat-item"><span>Times Got Bonus:</span><span>${s.bonusCount}</span></div>
            <div class="stat-item"><span>% Games w/ Yahtzee:</span><span>${((s.gamesWithYahtzee / s.games) * 100).toFixed(1)}%</span></div>
            <div class="stat-item"><span>Top Scratch:</span><span>${scratchCats[0] ? scratchCats[0][0] + ' (' + scratchCats[0][1] + ')' : "-"}</span></div>
            <button class="dashboard-btn" onclick="deletePlayerStats('${player}')">Delete ${player}'s Stats</button>`;


        const chartBtn = document.createElement("button");
        chartBtn.className = "dashboard-btn";
        chartBtn.innerText = "Show Performance Charts";
        chartBtn.onclick = () => toggleCharts(player, { ...s, overallAvgScore }, chartBtn);
        content.appendChild(chartBtn);


        card.appendChild(header);
        card.appendChild(content);


        header.addEventListener("click", () => { content.style.display = content.style.display === "none" ? "block" : "none"; });
        statsDiv.appendChild(card);
    });
}


function showStats() {
 hidePlayerCardContainer();
 document.getElementById("statsDashboard").style.display = "block";
 updateStatsDashboard();
}
function hideStats() {
 document.getElementById("statsDashboard").style.display = "none";
}

// --- Settings Page ---
function showSettings() {
    document.getElementById('playerSetup').style.display = 'none';
    document.getElementById('statsDashboard').style.display = 'none';
    document.getElementById('settingsPage').style.display = 'flex';
}

function hideSettings() {
    document.getElementById('settingsPage').style.display = 'none';
    document.getElementById('playerSetup').style.display = 'flex';
}

// --- Dark Mode ---
function toggleDarkMode() {
    document.body.classList.toggle('dark-mode');
    const isDarkMode = document.body.classList.contains('dark-mode');
    localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
    document.getElementById('darkModeToggle').checked = isDarkMode;
}

function loadTheme() {
    const theme = localStorage.getItem('theme');
    if (theme === 'dark') {
        document.body.classList.add('dark-mode');
        document.getElementById('darkModeToggle').checked = true;
    }
}

// --- Rules Modal ---
function showRulesModal() {
    document.getElementById('rulesModal').style.display = 'flex';
}
function closeRulesModal() {
    document.getElementById('rulesModal').style.display = 'none';
}


function deletePlayerStats(playerName) {
    showConfirmModal("Delete Stats", `Are you sure you want to remove ${playerName} from all historical games and delete their stats? This cannot be undone.`,
        () => {
            // Create a deep, local copy for modification, completely disconnected from the live listener.
            let currentHistory = JSON.parse(JSON.stringify(gameHistory));

            // Use .map to create a new history, modifying games along the way
            const newGameHistory = currentHistory.map(game => {
                const newResult = game.result.filter(p => p.name !== playerName);
                if (newResult.length === 0) {
                    return null; // This game will be filtered out
                }
                return { ...game, result: newResult };
            }).filter(game => game !== null); // Remove the nullified games

            // Now, safely overwrite the database with this corrected version
            overwriteData(newGameHistory, `Successfully removed ${playerName}'s stats.`);
        },
        () => {} // Action for "No"
    );
}

// --- Data Backup and Restore Functions ---
function exportData() {
    if (gameHistory.length === 0) {
        return showAlert("No Data", "There is no game data to export.");
    }
    const dataStr = JSON.stringify(gameHistory, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const downloadLink = document.createElement('a');
    downloadLink.href = URL.createObjectURL(dataBlob);
    const date = new Date();
    const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
    downloadLink.download = `yahtzee-backup-${dateString}.json`;
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
    showAlert("Export Successful", "Your data has been saved to a .json file.");
}

function handleFileImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const importedData = JSON.parse(e.target.result);
            if (!Array.isArray(importedData)) {
                throw new Error("Invalid file format.");
            }
            showConfirmModal(
                "Confirm Import",
                "This will overwrite ALL current game data with the backup file. This cannot be undone. Are you sure?",
                () => overwriteData(importedData, "Your data has been successfully restored."),
                () => { document.getElementById('importFile').value = ''; }
            );
        } catch (error) {
            showAlert("Import Error", `Failed to parse the file. Please ensure it is a valid backup. Error: ${error.message}`);
            document.getElementById('importFile').value = '';
        }
    };
    reader.readAsText(file);
}

function overwriteData(newData, successMessage) {
    if (!db) {
        showAlert("Offline", "Cannot perform this action while offline.");
        return;
    }

    // 1. Detach the listener to prevent race conditions
    if (firestoreListener) {
        console.log("Detaching Firestore listener for overwrite.");
        firestoreListener(); // This is the unsubscribe function
        firestoreListener = null;
    }

    showAlert("Processing...", "Please wait. Your data is being updated.");
    
    // 2. Update local state immediately for a responsive feel
    gameHistory = newData;
    localStorage.setItem("yahtzeeGameHistory", JSON.stringify(gameHistory));
    
    // If stats are visible, update them. Otherwise, they'll update when next opened.
    if (document.getElementById('statsDashboard').style.display === 'block') {
        updateStatsDashboard();
    }

    // 3. Sync with Firestore: Wipe the old collection and upload the new one.
    db.collection("yahtzeeGames").get().then(snapshot => {
        const deletePromises = snapshot.docs.map(doc => doc.ref.delete());
        return Promise.all(deletePromises);
    }).then(() => {
        const addPromises = newData.map(game => db.collection("yahtzeeGames").add(game));
        return Promise.all(addPromises);
    }).then(() => {
        showAlert("Success", successMessage);
    }).catch(err => {
        console.error("Error during data overwrite: ", err);
        showAlert("Error", "An error occurred while syncing with the database.");
    }).finally(() => {
        // 4. Re-attach the listener regardless of success or failure
        console.log("Re-attaching Firestore listener.");
        attachFirestoreListener();
        // Reset file input in case it was used for an import
        document.getElementById('importFile').value = '';
    });
}

document.getElementById('importFile').addEventListener('change', handleFileImport, false);


function clearGameData() {
    showConfirmModal("Delete All Data", "Are you sure you want to delete ALL game data from this device and the cloud? This is permanent.",
        () => {
            overwriteData([], "All game data has been deleted.");
            // Also clear recent players, as they are derived from game data
            recentPlayers = [];
            localStorage.removeItem("recentPlayers");
            renderRecentPlayers();
        },
        () => {}
    );
}


// Initial render for recent players
renderRecentPlayers();
loadTheme(); // Load saved theme on startup


// --- PWA Update Logic ---
let newWorker;
let updateAvailable = false;

function showUpdateBar() {
    updateAvailable = true;
    const notification = document.getElementById('update-notification');
    notification.style.display = 'block';
}

function installUpdate() {
    if(newWorker) {
        newWorker.postMessage({ action: 'skipWaiting' });
    }
}

window.addEventListener('load', () => {
    if ('serviceWorker' in navigator) {
        // The service worker can only be registered on http/https origins.
        // This check prevents an error in environments that use other protocols (e.g., 'blob:').
        if (window.location.protocol.startsWith('http')) {
            navigator.serviceWorker.register('./service-worker.js').then(reg => {
                reg.addEventListener('updatefound', () => {
                    newWorker = reg.installing;
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            showUpdateBar();
                        }
                    });
                });
            }).catch(error => {
                console.error('Service Worker registration failed:', error);
            });

            let refreshing;
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                if (refreshing) return;
                window.location.reload();
                refreshing = true;
            });
        } else {
            console.warn('Service Worker registration skipped: The protocol "' + window.location.protocol + '" is not supported.');
        }
    }
});


// --- Screen Wake Lock ---
let screenWakeLock = null;

async function requestWakeLock() {
  if ('wakeLock' in navigator) {
    try {
      screenWakeLock = await navigator.wakeLock.request('screen');
      screenWakeLock.addEventListener('release', () => {
        console.log('Screen Wake Lock was released');
      });
      console.log('Screen Wake Lock is active.');
    } catch (err) {
      console.error(`${err.name}, ${err.message}`);
    }
  } else {
    console.log('Wake Lock API not supported.');
  }
}

async function releaseWakeLock() {
  if (screenWakeLock !== null) {
    await screenWakeLock.release();
    screenWakeLock = null;
    console.log('Screen Wake Lock released.');
  }
}

function toggleWakeLock() {
  const isChecked = document.getElementById('wakeLockToggle').checked;
  if (isChecked) {
    requestWakeLock();
    localStorage.setItem('keepScreenOn', 'true');
  } else {
    releaseWakeLock();
    localStorage.setItem('keepScreenOn', 'false');
  }
}

function loadWakeLockSetting() {
  const keepScreenOn = localStorage.getItem('keepScreenOn');
  if (keepScreenOn === 'true') {
    document.getElementById('wakeLockToggle').checked = true;
    requestWakeLock();
  }
}

// Re-acquire the wake lock if returning to the tab
async function handleVisibilityChange() {
  if (screenWakeLock === null && document.visibilityState === 'visible') {
    const keepScreenOn = localStorage.getItem('keepScreenOn');
    if (keepScreenOn === 'true') {
        console.log('Re-acquiring wake lock on visibility change.');
        await requestWakeLock();
    }
  }
}

document.addEventListener('visibilitychange', handleVisibilityChange);

// --- Virtual Dice Functions ---
function toggleVirtualDice() {
    const isChecked = document.getElementById('virtualDiceToggle').checked;
    virtualDiceMode = isChecked;
    localStorage.setItem('virtualDiceMode', isChecked ? 'true' : 'false');
    if (turnMode) { // If in a game, immediately show/hide the roller
        document.getElementById('dice-roller-container').style.display = isChecked ? 'block' : 'none';
        if(isChecked) resetDiceRoller();
    }
}

function loadVirtualDiceSetting() {
    const setting = localStorage.getItem('virtualDiceMode');
    if (setting === 'true') {
        virtualDiceMode = true;
        document.getElementById('virtualDiceToggle').checked = true;
    }
}

function renderDice() {
    const diceArea = document.getElementById('dice-area');
    diceArea.innerHTML = '';
    dice.forEach((die, index) => {
        const dieEl = document.createElement('div');
        dieEl.className = `die ${die.kept ? 'kept' : ''}`;
        dieEl.onclick = () => toggleKeepDie(index);

        const faceEl = document.createElement('div');
        faceEl.className = `die-face face-${die.value}`;
        for (let i = 1; i <= 9; i++) {
            const dot = document.createElement('div');
            dot.className = `die-dot dot-${i}`;
            faceEl.appendChild(dot);
        }
        dieEl.appendChild(faceEl);
        diceArea.appendChild(dieEl);
    });
}

function rollDice() {
    if (rollsLeft <= 0) return;

    rollsLeft--;
    dice.forEach((die, index) => {
        if (!die.kept) {
            die.value = Math.floor(Math.random() * 6) + 1;
            // Add animation
            const dieEl = document.getElementById('dice-area').children[index];
            dieEl.classList.add('rolling');
            setTimeout(() => dieEl.classList.remove('rolling'), 500);
        }
    });

    // We need a slight delay for the animation to be seen before the re-render.
    setTimeout(() => {
        renderDice();
        document.getElementById('rolls-left').innerText = `Rolls Left: ${rollsLeft}`;
        document.getElementById('roll-dice-btn').disabled = rollsLeft === 0;
    }, 100);
}

function toggleKeepDie(index) {
    if (rollsLeft < 3) { // Can't keep dice before the first roll
        dice[index].kept = !dice[index].kept;
        renderDice();
    }
}

function resetDiceRoller() {
    dice.forEach(die => die.kept = false);
    rollsLeft = 3;
    document.getElementById('rolls-left').innerText = `Rolls Left: ${rollsLeft}`;
    document.getElementById('roll-dice-btn').disabled = false;
    renderDice();
}

// Load all settings on startup
loadTheme();
loadWakeLockSetting();
loadVirtualDiceSetting();
</script>
</body>
</html>



















